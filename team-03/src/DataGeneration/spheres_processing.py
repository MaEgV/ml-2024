import os
import numpy as np
import typing as tp
from PIL import Image
from scipy.special import jv
from itertools import product
from scipy.ndimage.filters import gaussian_filter
from math import ceil

from image_processing import gaus_blurring, draw_mask_in_position, center_by_intensivity

"""
Functions to average real data
"""
def upload_tiff_images_from_folder(path:str) -> tp.List[np.ndarray]:
    if os.path.isdir(path) == False:
        raise Exception(f"Exception: path '{path}' doesnt exist!")

    paths = []
    for file in os.listdir(path):
        if file.endswith(".tiff") or file.endswith(".tif"):
            paths.append(path + "/" + file)

    tiffsImages = list()
    for path in paths:
        image = Image.open(path)
        ncols, nrows = image.size
        nlayers =  image.n_frames

        imgArray = np.ndarray([nlayers,nrows,ncols])
        for i in range(nlayers):
            image.seek(i)
            imgArray[i,:,:] = np.array(image)
        tiffsImages.append(imgArray)
        
    return tiffsImages
    

def averaging_beads(beads_images : tp.List[np.ndarray], 
                    average_bead_shape : tp.Tuple[int],
                    gauss_blur_sigma:float = None,
                    min_border : int = None) -> np.ndarray:
    average_bead = np.zeros(average_bead_shape)
    average_bead_center = np.array(average_bead_shape) // 2
    cnt = 0
    
    for img in beads_images:
        # blur to destroy peaks generated by noises
        if gauss_blur_sigma != None:
            blurred_img = gaus_blurring(img, gauss_blur_sigma)
            cur_img_center = np.argwhere(blurred_img == np.amax(blurred_img))
        else:
            cur_img_center = np.argwhere(img == np.amax(img))
        
        # if many maximum coords - skip img 
        if cur_img_center.shape[0] > 1:
            continue
        average_bead = draw_mask_in_position(average_bead, img, average_bead_center, cur_img_center[0])
        print(average_bead_center, np.argwhere(average_bead == np.amax(average_bead)))
        cnt += 1
    print(f"Cnt: {cnt}")
    average_bead = average_bead if cnt == 0 else average_bead / cnt

    if min_border != None:
        average_bead[average_bead <= min_border] = 0
    return average_bead

def generate_average_bead(blured_beads_path:str,
                            bead_shape:tp.Tuple[int],
                            low_border:int = 1,
                            gauss_blur_sigma:float = None) -> tp.Tuple[np.ndarray]:

    beads_imgs = upload_tiff_images_from_folder(blured_beads_path)
    print(len(beads_imgs), beads_imgs)
    average_bead = averaging_beads(beads_imgs, bead_shape, gauss_blur_sigma, min_border=low_border)
    #print(np.unravel_index(average_bead.argmax(), average_bead.shape))
    average_bead = center_by_intensivity(average_bead)
    #print(np.unravel_index(average_bead.argmax(), average_bead.shape))
    return average_bead

"""
Functions to model true sphere's image with linear function
"""
def generate_circle(rad_x : float, rad_y : float, rad_z : float, 
        center_layer : float, center_row : float, center_col : float, 
        shape : tp.Tuple[int], lower_intensity : int) -> np.ndarray:
    circle = np.zeros(shape=shape, dtype="float32")

    for layer in range(shape[0]):
        for row in range(shape[1]):
            for col in range(shape[2]):
                if (layer - center_layer) ** 2 / (rad_z * rad_z) + (
                    row - center_row
                ) ** 2 / (rad_x * rad_x) + (col - center_col) ** 2 / (
                    rad_y * rad_y
                ) <= 1:
                    circle[layer][row][col] = lower_intensity + (255 - lower_intensity) * (
                        1
                        - (
                            (layer - center_layer) ** 2 / (rad_z * rad_z)
                            + (row - center_row) ** 2 / (rad_x * rad_x)
                            + (col - center_col) ** 2 / (rad_y * rad_y)
                        )
                    )

    return circle

def model_3d_linear_bead(image_size:tp.Tuple[int], 
                z_scale:float, 
                x_scale:float, 
                y_scale:float, 
                bead_diameter:float,
                lower_intensity : int = 242) -> np.ndarray:
    
    rad_z = bead_diameter / 2 / z_scale
    rad_x = bead_diameter / 2 / x_scale
    rad_y = bead_diameter / 2 / y_scale

    center_layer, center_row, center_col = np.array(image_size) // 2

    img = generate_circle(rad_x, rad_y, rad_z, center_layer, center_row, center_col, image_size, lower_intensity)
    return img

"""
Functions to model true sphere's image with point airy function
"""
def point_function_airy(pt:np.ndarray, r0:np.ndarray, scale:np.ndarray, bead_diameter:float, 
                        max_light_intensity:int=255, zoomfactor:float=2.6) -> float:
    """
    Zoom of bead circle  from microscope
    Radius = self.BeadDiameter / 2
    Center  r0 - np.array[0:2].
    Function return Airy disk intesity within first circle if pt in sphere and 0 if out of sphere.
    pt and r0 are np.array vectors : np.array([x,y,z])
    All  dimension in pixels are equal to x-dimension
    """
    length = (abs(r0[0] - pt[0]) * scale[0]) ** 2 + (abs(r0[1] - pt[1]) * scale[1]) ** 2 + (abs(r0[2] - pt[2]) * scale[2]) ** 2
    rad_square = (bead_diameter / 2.0) ** 2
    if rad_square - length >= 0.000001:
        R = np.sqrt(rad_square - length) * zoomfactor
        ptd = [pt[0] * scale[0], pt[1] * scale[1], pt[2] * scale[2]]
        r0d = [r0[0] * scale[0], r0[1] * scale[1], r0[2] * scale[2]]

        distSq = (ptd[0] - r0d[0]) ** 2 + (ptd[1] - r0d[1]) ** 2 + (ptd[2] - r0d[2]) ** 2
        dist = np.sqrt(distSq)
        x = dist / R * 4.0
        if abs(x) >= 0.00001:  # Zero-criterion
        #     # NOTE: If 'x' is equal zero - result == nan!. To prevent it - make result equal 'maxIntensity'
            result = (2.0 * jv(1, x) / x) ** 2 * max_light_intensity
        else:
            result = max_light_intensity

    else:
        result = 0

    return result


def generate_airy_circle(z_scale : float, x_scale : float, y_scale : float, bead_diameter : float, 
        center_layer : float, center_row : float, center_col : float, 
        shape : tp.Tuple[int], max_light_intensity:int = 255, zoom_factor:float=2.6) -> np.ndarray:
    """
    Create ideal  sphere array corresponding to sphere_type
    """
    img_center = np.array([center_layer, center_row, center_col])
    scale = np.array([z_scale, x_scale, y_scale])
    circle = np.zeros(shape=shape, dtype="float32")
    
    for i in range(shape[0]):
        for j in range(shape[1]):
            for k in range(shape[2]):
                #if i == 14 and j == 31 and k == 31:
                #    print(i, j, k)
                circle[i, j, k] = point_function_airy(
                    np.array([i, j, k]), img_center, scale, bead_diameter, max_light_intensity, zoom_factor
                )
    return circle.astype("uint8")

def model_3d_airy_bead(image_size:tp.Tuple[int], 
                z_scale:float, 
                x_scale:float, 
                y_scale:float, 
                bead_diameter:float,
                max_light_intensity : int = 255, 
                zoomfactor : float = 2.6) -> np.ndarray:
    
    center_layer, center_row, center_col = np.array(image_size) // 2
    img = generate_airy_circle(z_scale, x_scale, y_scale, bead_diameter,
        center_layer, center_row, center_col, image_size, max_light_intensity, zoomfactor)
    return img

def gaussian_blurring_sphere(sphere : np.ndarray, z_scale:float, x_scale:float, y_scale:float, 
                            gaussian_sigma:float=1.5, additional_space_xy:float=0.100, additional_space_z:float=0.100) -> np.ndarray:
    min_scale = min(z_scale, x_scale, y_scale)
    z_sigma = min_scale / z_scale * gaussian_sigma
    x_sigma = min_scale / x_scale * gaussian_sigma
    y_sigma = min_scale / y_scale * gaussian_sigma

    # watch this to understand truncate counting: https://stackoverflow.com/questions/25216382/gaussian-filter-in-scipy
    window_rad_z = ceil(additional_space_z / z_scale)
    window_rad_x = ceil(additional_space_xy / x_scale)
    window_rad_y = ceil(additional_space_xy / y_scale)
    
    blurred_sphere = gaussian_filter(sphere, sigma=(z_sigma, x_sigma, y_sigma), radius=(window_rad_z, window_rad_x ,window_rad_y))
    blurred_sphere = (blurred_sphere / np.amax(blurred_sphere) * np.amax(sphere)).astype("uint8")
    return blurred_sphere